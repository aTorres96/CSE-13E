#include <math.h>
#include <stdio.h>
#include <string.h>
#include "BOARD.h"
#include "Negotiation.h"


NegotiationData NegotiationHash(NegotiationData secret) {

    uint64_t hash = (secret * secret);
    

    return (NegotiationData)(hash % PUBLIC_KEY);
}

/**
 * Detect cheating.  An accepting agent will receive both a commitment hash
 * and a secret number from the challenging agent.  This function
 * verifies that the secret and the commitment hash agree, hopefully
 * detecting cheating by the challenging agent.
 *
 * @param secret        //the previously secret number that the challenging agent has revealed
 * @param commitment    //the hash of the secret number
 * @return TRUE if the commitment validates the revealed secret, FALSE otherwise
 */
int NegotiationVerify(NegotiationData secret, NegotiationData commitment) {
    
    NegotiationData hash = NegotiationHash(secret);

    if (hash == commitment) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/**
 * The coin-flip protocol uses random numbers generated by both
 * agents to determine the outcome of the coin flip.
 *
 * The parity of a bitstring is 1 if there are an odd number of one bits,
 *   and 0 otherwise.
 * So, for example, the number 0b01101011 has 5 ones.  If the parity of
 * A XOR B is 1, then the outcome is HEADS.  Otherwise, the outcome is TAILS.
 */
NegotiationOutcome NegotiateCoinFlip(NegotiationData A, NegotiationData B) {

    NegotiationData var = A ^ B;
    uint16_t turn, ones;
    turn = 0;
    ones = 0;

    while (var) {
        if (((var & 0x01) % 2) == 1) {
            ones++;
        }
        var >>= 1;
    }
    turn = ones % 2;
    if (turn == 0) {
        return TAILS;
    } else {
        return HEADS;
    }


}






/**
 * Extra credit: 
 * Use either or both of these two functions if you want to generate a "cheating" agent.  
 *
 * To get extra credit, define these functions 
 * and use these functions in agent.c to generate A and/or B
 * 
 * Your agent only needs to be able to cheat at one role for extra credit.  They must result in 
 * your agent going first more than 75% of the time in that role when
 * competing against a fair agent (that is, an agent that uses purely random A and B).
 *
 * You must state that you did this at the top of your README, and describe your 
 * strategy thoroughly.
 */
NegotiationData NegotiateGenerateBGivenHash(NegotiationData hash_a);
NegotiationData NegotiateGenerateAGivenB(NegotiationData B);

